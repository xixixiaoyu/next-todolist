# 23 - ç›‘æ§è¿ç»´

æœ¬ç« å°†è¯¦ç»†ä»‹ç»å¦‚ä½•å»ºç«‹å®Œæ•´çš„ç›‘æ§å’Œè¿ç»´ä½“ç³»ï¼Œç¡®ä¿åº”ç”¨åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ç¨³å®šè¿è¡Œã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- æŒæ¡åº”ç”¨æ€§èƒ½ç›‘æ§çš„å…³é”®æŒ‡æ ‡
- å­¦ä¼šè®¾ç½®å‘Šè­¦å’Œé€šçŸ¥ç³»ç»Ÿ
- äº†è§£æ—¥å¿—æ”¶é›†å’Œåˆ†ææ–¹æ³•
- æŒæ¡æ•…éšœæ’æŸ¥å’Œæ¢å¤æµç¨‹

## ğŸ“Š ç›‘æ§ä½“ç³»æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç›‘æ§ä½“ç³»                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åº”ç”¨å±‚ç›‘æ§                                              â”‚
â”‚  â”œâ”€â”€ æ€§èƒ½æŒ‡æ ‡ (Web Vitals, API å“åº”æ—¶é—´)                â”‚
â”‚  â”œâ”€â”€ é”™è¯¯ç›‘æ§ (JavaScript é”™è¯¯, API é”™è¯¯)               â”‚
â”‚  â”œâ”€â”€ ç”¨æˆ·è¡Œä¸º (é¡µé¢è®¿é—®, åŠŸèƒ½ä½¿ç”¨)                      â”‚
â”‚  â””â”€â”€ ä¸šåŠ¡æŒ‡æ ‡ (ç”¨æˆ·æ³¨å†Œ, ä»»åŠ¡åˆ›å»º)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åŸºç¡€è®¾æ–½ç›‘æ§                                            â”‚
â”‚  â”œâ”€â”€ æœåŠ¡å™¨èµ„æº (CPU, å†…å­˜, ç£ç›˜)                       â”‚
â”‚  â”œâ”€â”€ ç½‘ç»œçŠ¶æ€ (å»¶è¿Ÿ, å¸¦å®½, å¯ç”¨æ€§)                      â”‚
â”‚  â”œâ”€â”€ æ•°æ®åº“æ€§èƒ½ (æŸ¥è¯¢æ—¶é—´, è¿æ¥æ•°)                      â”‚
â”‚  â””â”€â”€ ç¬¬ä¸‰æ–¹æœåŠ¡ (Supabase, CDN)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å‘Šè­¦å’Œé€šçŸ¥                                              â”‚
â”‚  â”œâ”€â”€ å®æ—¶å‘Šè­¦ (Slack, é‚®ä»¶, çŸ­ä¿¡)                       â”‚
â”‚  â”œâ”€â”€ å‘Šè­¦è§„åˆ™ (é˜ˆå€¼, è¶‹åŠ¿, å¼‚å¸¸)                        â”‚
â”‚  â””â”€â”€ å‡çº§ç­–ç•¥ (è‡ªåŠ¨æ¢å¤, äººå·¥ä»‹å…¥)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ” æ€§èƒ½ç›‘æ§

### 1. Web Vitals ç›‘æ§

```typescript
// src/lib/monitoring/web-vitals.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals'

interface WebVitalMetric {
  name: string
  value: number
  rating: 'good' | 'needs-improvement' | 'poor'
  delta: number
  id: string
  timestamp: number
}

class WebVitalsMonitor {
  private metrics: WebVitalMetric[] = []
  private reportEndpoint = '/api/analytics/web-vitals'

  init() {
    // ç›‘æ§æ ¸å¿ƒ Web Vitals
    getCLS(this.handleMetric.bind(this))
    getFID(this.handleMetric.bind(this))
    getFCP(this.handleMetric.bind(this))
    getLCP(this.handleMetric.bind(this))
    getTTFB(this.handleMetric.bind(this))

    // é¡µé¢å¸è½½æ—¶å‘é€æ•°æ®
    window.addEventListener('beforeunload', () => {
      this.sendMetrics()
    })

    // å®šæœŸå‘é€æ•°æ®
    setInterval(() => {
      this.sendMetrics()
    }, 30000) // æ¯ 30 ç§’å‘é€ä¸€æ¬¡
  }

  private handleMetric(metric: any) {
    const webVitalMetric: WebVitalMetric = {
      name: metric.name,
      value: metric.value,
      rating: metric.rating,
      delta: metric.delta,
      id: metric.id,
      timestamp: Date.now(),
    }

    this.metrics.push(webVitalMetric)

    // å®æ—¶æŠ¥å‘Šå…³é”®æŒ‡æ ‡
    if (metric.rating === 'poor') {
      this.reportCriticalMetric(webVitalMetric)
    }
  }

  private async reportCriticalMetric(metric: WebVitalMetric) {
    try {
      await fetch('/api/alerts/critical-metric', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          metric,
          url: window.location.href,
          userAgent: navigator.userAgent,
          timestamp: Date.now(),
        }),
      })
    } catch (error) {
      console.error('Failed to report critical metric:', error)
    }
  }

  private async sendMetrics() {
    if (this.metrics.length === 0) return

    try {
      await fetch(this.reportEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          metrics: this.metrics,
          url: window.location.href,
          timestamp: Date.now(),
        }),
      })

      this.metrics = [] // æ¸…ç©ºå·²å‘é€çš„æŒ‡æ ‡
    } catch (error) {
      console.error('Failed to send web vitals:', error)
    }
  }
}

export const webVitalsMonitor = new WebVitalsMonitor()
```

### 2. API æ€§èƒ½ç›‘æ§

```typescript
// src/lib/monitoring/api-monitor.ts
interface ApiMetric {
  url: string
  method: string
  status: number
  duration: number
  timestamp: number
  error?: string
}

class ApiMonitor {
  private metrics: ApiMetric[] = []
  private slowRequestThreshold = 2000 // 2 ç§’
  private errorRateThreshold = 0.05 // 5%

  // æ‹¦æˆª fetch è¯·æ±‚
  init() {
    const originalFetch = window.fetch
    
    window.fetch = async (...args) => {
      const startTime = performance.now()
      const url = args[0] as string
      const options = args[1] || {}
      const method = options.method || 'GET'

      try {
        const response = await originalFetch(...args)
        const duration = performance.now() - startTime

        const metric: ApiMetric = {
          url,
          method,
          status: response.status,
          duration,
          timestamp: Date.now(),
        }

        this.recordMetric(metric)
        return response
      } catch (error) {
        const duration = performance.now() - startTime
        const metric: ApiMetric = {
          url,
          method,
          status: 0,
          duration,
          timestamp: Date.now(),
          error: error instanceof Error ? error.message : 'Unknown error',
        }

        this.recordMetric(metric)
        throw error
      }
    }
  }

  private recordMetric(metric: ApiMetric) {
    this.metrics.push(metric)

    // æ£€æŸ¥æ…¢è¯·æ±‚
    if (metric.duration > this.slowRequestThreshold) {
      this.reportSlowRequest(metric)
    }

    // æ£€æŸ¥é”™è¯¯ç‡
    this.checkErrorRate()

    // å®šæœŸæ¸…ç†æ—§æ•°æ®
    if (this.metrics.length > 1000) {
      this.metrics = this.metrics.slice(-500)
    }
  }

  private reportSlowRequest(metric: ApiMetric) {
    fetch('/api/alerts/slow-request', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(metric),
    }).catch(console.error)
  }

  private checkErrorRate() {
    const recentMetrics = this.metrics.filter(
      m => Date.now() - m.timestamp < 5 * 60 * 1000 // æœ€è¿‘ 5 åˆ†é’Ÿ
    )

    if (recentMetrics.length < 10) return // æ ·æœ¬å¤ªå°‘

    const errorCount = recentMetrics.filter(m => m.status >= 400 || m.error).length
    const errorRate = errorCount / recentMetrics.length

    if (errorRate > this.errorRateThreshold) {
      this.reportHighErrorRate(errorRate, recentMetrics.length)
    }
  }

  private reportHighErrorRate(errorRate: number, totalRequests: number) {
    fetch('/api/alerts/high-error-rate', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        errorRate,
        totalRequests,
        timestamp: Date.now(),
      }),
    }).catch(console.error)
  }

  getMetrics() {
    return this.metrics
  }

  getStats() {
    const recentMetrics = this.metrics.filter(
      m => Date.now() - m.timestamp < 60 * 60 * 1000 // æœ€è¿‘ 1 å°æ—¶
    )

    const totalRequests = recentMetrics.length
    const errorCount = recentMetrics.filter(m => m.status >= 400 || m.error).length
    const avgDuration = recentMetrics.reduce((sum, m) => sum + m.duration, 0) / totalRequests

    return {
      totalRequests,
      errorCount,
      errorRate: errorCount / totalRequests,
      avgDuration,
      slowRequests: recentMetrics.filter(m => m.duration > this.slowRequestThreshold).length,
    }
  }
}

export const apiMonitor = new ApiMonitor()
```

## ğŸš¨ å‘Šè­¦ç³»ç»Ÿ

### 1. å‘Šè­¦è§„åˆ™é…ç½®

```typescript
// src/lib/monitoring/alert-rules.ts
export interface AlertRule {
  id: string
  name: string
  description: string
  condition: AlertCondition
  severity: 'low' | 'medium' | 'high' | 'critical'
  channels: AlertChannel[]
  cooldown: number // å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
  enabled: boolean
}

export interface AlertCondition {
  metric: string
  operator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte'
  threshold: number
  timeWindow: number // æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
  minSamples?: number // æœ€å°æ ·æœ¬æ•°
}

export interface AlertChannel {
  type: 'email' | 'slack' | 'webhook' | 'sms'
  config: Record<string, any>
}

export const alertRules: AlertRule[] = [
  {
    id: 'high-error-rate',
    name: 'é«˜é”™è¯¯ç‡å‘Šè­¦',
    description: 'API é”™è¯¯ç‡è¶…è¿‡ 5%',
    condition: {
      metric: 'api.error_rate',
      operator: 'gt',
      threshold: 0.05,
      timeWindow: 300, // 5 åˆ†é’Ÿ
      minSamples: 10,
    },
    severity: 'high',
    channels: [
      {
        type: 'slack',
        config: {
          webhook: process.env.SLACK_WEBHOOK_URL,
          channel: '#alerts',
        },
      },
      {
        type: 'email',
        config: {
          recipients: ['dev-team@example.com'],
        },
      },
    ],
    cooldown: 900, // 15 åˆ†é’Ÿ
    enabled: true,
  },
  {
    id: 'slow-response',
    name: 'å“åº”æ—¶é—´è¿‡æ…¢',
    description: 'API å¹³å‡å“åº”æ—¶é—´è¶…è¿‡ 2 ç§’',
    condition: {
      metric: 'api.avg_response_time',
      operator: 'gt',
      threshold: 2000,
      timeWindow: 600, // 10 åˆ†é’Ÿ
    },
    severity: 'medium',
    channels: [
      {
        type: 'slack',
        config: {
          webhook: process.env.SLACK_WEBHOOK_URL,
          channel: '#performance',
        },
      },
    ],
    cooldown: 1800, // 30 åˆ†é’Ÿ
    enabled: true,
  },
  {
    id: 'database-connection-error',
    name: 'æ•°æ®åº“è¿æ¥é”™è¯¯',
    description: 'æ•°æ®åº“è¿æ¥å¤±è´¥',
    condition: {
      metric: 'database.connection_error',
      operator: 'gt',
      threshold: 0,
      timeWindow: 60, // 1 åˆ†é’Ÿ
    },
    severity: 'critical',
    channels: [
      {
        type: 'slack',
        config: {
          webhook: process.env.SLACK_WEBHOOK_URL,
          channel: '#critical-alerts',
        },
      },
      {
        type: 'email',
        config: {
          recipients: ['oncall@example.com'],
        },
      },
      {
        type: 'sms',
        config: {
          numbers: ['+1234567890'],
        },
      },
    ],
    cooldown: 300, // 5 åˆ†é’Ÿ
    enabled: true,
  },
]
```

### 2. å‘Šè­¦å¤„ç†å™¨

```typescript
// src/lib/monitoring/alert-handler.ts
import { AlertRule, AlertChannel } from './alert-rules'

interface Alert {
  id: string
  ruleId: string
  severity: string
  message: string
  timestamp: number
  resolved: boolean
  metadata?: Record<string, any>
}

class AlertHandler {
  private activeAlerts = new Map<string, Alert>()
  private lastAlertTime = new Map<string, number>()

  async processAlert(rule: AlertRule, value: number, metadata?: Record<string, any>) {
    const now = Date.now()
    const lastAlert = this.lastAlertTime.get(rule.id) || 0

    // æ£€æŸ¥å†·å´æ—¶é—´
    if (now - lastAlert < rule.cooldown * 1000) {
      return
    }

    const alert: Alert = {
      id: `${rule.id}-${now}`,
      ruleId: rule.id,
      severity: rule.severity,
      message: this.generateAlertMessage(rule, value),
      timestamp: now,
      resolved: false,
      metadata,
    }

    this.activeAlerts.set(alert.id, alert)
    this.lastAlertTime.set(rule.id, now)

    // å‘é€å‘Šè­¦
    await this.sendAlert(alert, rule.channels)

    // è®°å½•å‘Šè­¦
    await this.logAlert(alert)
  }

  private generateAlertMessage(rule: AlertRule, value: number): string {
    return `ğŸš¨ ${rule.name}\n` +
           `æè¿°: ${rule.description}\n` +
           `å½“å‰å€¼: ${value}\n` +
           `é˜ˆå€¼: ${rule.condition.threshold}\n` +
           `æ—¶é—´: ${new Date().toISOString()}`
  }

  private async sendAlert(alert: Alert, channels: AlertChannel[]) {
    const promises = channels.map(channel => this.sendToChannel(alert, channel))
    await Promise.allSettled(promises)
  }

  private async sendToChannel(alert: Alert, channel: AlertChannel) {
    try {
      switch (channel.type) {
        case 'slack':
          await this.sendSlackAlert(alert, channel.config)
          break
        case 'email':
          await this.sendEmailAlert(alert, channel.config)
          break
        case 'webhook':
          await this.sendWebhookAlert(alert, channel.config)
          break
        case 'sms':
          await this.sendSmsAlert(alert, channel.config)
          break
      }
    } catch (error) {
      console.error(`Failed to send alert to ${channel.type}:`, error)
    }
  }

  private async sendSlackAlert(alert: Alert, config: any) {
    const payload = {
      channel: config.channel,
      username: 'AlertBot',
      icon_emoji: ':rotating_light:',
      attachments: [
        {
          color: this.getSeverityColor(alert.severity),
          title: `${alert.severity.toUpperCase()} Alert`,
          text: alert.message,
          timestamp: Math.floor(alert.timestamp / 1000),
        },
      ],
    }

    await fetch(config.webhook, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    })
  }

  private async sendEmailAlert(alert: Alert, config: any) {
    const emailData = {
      to: config.recipients,
      subject: `[${alert.severity.toUpperCase()}] ${alert.message.split('\n')[0]}`,
      html: alert.message.replace(/\n/g, '<br>'),
    }

    await fetch('/api/notifications/email', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(emailData),
    })
  }

  private async sendWebhookAlert(alert: Alert, config: any) {
    await fetch(config.url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...config.headers,
      },
      body: JSON.stringify(alert),
    })
  }

  private async sendSmsAlert(alert: Alert, config: any) {
    const smsData = {
      numbers: config.numbers,
      message: alert.message.substring(0, 160), // SMS é•¿åº¦é™åˆ¶
    }

    await fetch('/api/notifications/sms', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(smsData),
    })
  }

  private getSeverityColor(severity: string): string {
    const colors = {
      low: '#36a64f',
      medium: '#ff9500',
      high: '#ff0000',
      critical: '#8b0000',
    }
    return colors[severity as keyof typeof colors] || '#808080'
  }

  private async logAlert(alert: Alert) {
    try {
      await fetch('/api/alerts/log', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(alert),
      })
    } catch (error) {
      console.error('Failed to log alert:', error)
    }
  }

  async resolveAlert(alertId: string) {
    const alert = this.activeAlerts.get(alertId)
    if (alert) {
      alert.resolved = true
      await this.logAlert(alert)
    }
  }

  getActiveAlerts(): Alert[] {
    return Array.from(this.activeAlerts.values()).filter(alert => !alert.resolved)
  }
}

export const alertHandler = new AlertHandler()
```

## ğŸ“ˆ ç›‘æ§ä»ªè¡¨æ¿

### 1. å®æ—¶ç›‘æ§ç»„ä»¶

```typescript
// src/components/monitoring/monitoring-dashboard.tsx
'use client'

import { useState, useEffect } from 'react'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts'

interface MonitoringData {
  webVitals: {
    cls: number
    fid: number
    lcp: number
    fcp: number
    ttfb: number
  }
  apiMetrics: {
    totalRequests: number
    errorRate: number
    avgResponseTime: number
    slowRequests: number
  }
  systemHealth: {
    uptime: number
    memoryUsage: number
    cpuUsage: number
    diskUsage: number
  }
  alerts: Array<{
    id: string
    severity: string
    message: string
    timestamp: number
  }>
}

export function MonitoringDashboard() {
  const [data, setData] = useState<MonitoringData | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('/api/monitoring/dashboard')
        const monitoringData = await response.json()
        setData(monitoringData)
      } catch (error) {
        console.error('Failed to fetch monitoring data:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
    const interval = setInterval(fetchData, 30000) // æ¯ 30 ç§’æ›´æ–°

    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return <div className="p-6">åŠ è½½ç›‘æ§æ•°æ®...</div>
  }

  if (!data) {
    return <div className="p-6">æ— æ³•åŠ è½½ç›‘æ§æ•°æ®</div>
  }

  return (
    <div className="p-6 space-y-6">
      <h1 className="text-3xl font-bold">ç›‘æ§ä»ªè¡¨æ¿</h1>

      {/* å‘Šè­¦æ¦‚è§ˆ */}
      <Card>
        <CardHeader>
          <CardTitle>æ´»è·ƒå‘Šè­¦</CardTitle>
        </CardHeader>
        <CardContent>
          {data.alerts.length === 0 ? (
            <p className="text-green-600">âœ… æ— æ´»è·ƒå‘Šè­¦</p>
          ) : (
            <div className="space-y-2">
              {data.alerts.map(alert => (
                <div key={alert.id} className="flex items-center justify-between p-3 border rounded">
                  <div>
                    <Badge variant={alert.severity === 'critical' ? 'destructive' : 'secondary'}>
                      {alert.severity}
                    </Badge>
                    <span className="ml-2">{alert.message}</span>
                  </div>
                  <span className="text-sm text-gray-500">
                    {new Date(alert.timestamp).toLocaleTimeString()}
                  </span>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>

      {/* Web Vitals */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
        <MetricCard
          title="CLS"
          value={data.webVitals.cls.toFixed(3)}
          status={data.webVitals.cls < 0.1 ? 'good' : data.webVitals.cls < 0.25 ? 'warning' : 'poor'}
        />
        <MetricCard
          title="FID"
          value={`${data.webVitals.fid.toFixed(0)}ms`}
          status={data.webVitals.fid < 100 ? 'good' : data.webVitals.fid < 300 ? 'warning' : 'poor'}
        />
        <MetricCard
          title="LCP"
          value={`${(data.webVitals.lcp / 1000).toFixed(1)}s`}
          status={data.webVitals.lcp < 2500 ? 'good' : data.webVitals.lcp < 4000 ? 'warning' : 'poor'}
        />
        <MetricCard
          title="FCP"
          value={`${(data.webVitals.fcp / 1000).toFixed(1)}s`}
          status={data.webVitals.fcp < 1800 ? 'good' : data.webVitals.fcp < 3000 ? 'warning' : 'poor'}
        />
        <MetricCard
          title="TTFB"
          value={`${data.webVitals.ttfb.toFixed(0)}ms`}
          status={data.webVitals.ttfb < 800 ? 'good' : data.webVitals.ttfb < 1800 ? 'warning' : 'poor'}
        />
      </div>

      {/* API æŒ‡æ ‡ */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <MetricCard
          title="æ€»è¯·æ±‚æ•°"
          value={data.apiMetrics.totalRequests.toString()}
          status="good"
        />
        <MetricCard
          title="é”™è¯¯ç‡"
          value={`${(data.apiMetrics.errorRate * 100).toFixed(2)}%`}
          status={data.apiMetrics.errorRate < 0.01 ? 'good' : data.apiMetrics.errorRate < 0.05 ? 'warning' : 'poor'}
        />
        <MetricCard
          title="å¹³å‡å“åº”æ—¶é—´"
          value={`${data.apiMetrics.avgResponseTime.toFixed(0)}ms`}
          status={data.apiMetrics.avgResponseTime < 500 ? 'good' : data.apiMetrics.avgResponseTime < 2000 ? 'warning' : 'poor'}
        />
        <MetricCard
          title="æ…¢è¯·æ±‚æ•°"
          value={data.apiMetrics.slowRequests.toString()}
          status={data.apiMetrics.slowRequests === 0 ? 'good' : 'warning'}
        />
      </div>

      {/* ç³»ç»Ÿå¥åº· */}
      <Card>
        <CardHeader>
          <CardTitle>ç³»ç»Ÿå¥åº·</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
            <div className="text-center">
              <div className="text-2xl font-bold">{Math.floor(data.systemHealth.uptime / 3600)}h</div>
              <div className="text-sm text-gray-500">è¿è¡Œæ—¶é—´</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold">{data.systemHealth.memoryUsage.toFixed(1)}%</div>
              <div className="text-sm text-gray-500">å†…å­˜ä½¿ç”¨ç‡</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold">{data.systemHealth.cpuUsage.toFixed(1)}%</div>
              <div className="text-sm text-gray-500">CPU ä½¿ç”¨ç‡</div>
            </div>
            <div className="text-center">
              <div className="text-2xl font-bold">{data.systemHealth.diskUsage.toFixed(1)}%</div>
              <div className="text-sm text-gray-500">ç£ç›˜ä½¿ç”¨ç‡</div>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  )
}

function MetricCard({ 
  title, 
  value, 
  status 
}: { 
  title: string
  value: string
  status: 'good' | 'warning' | 'poor'
}) {
  const statusColors = {
    good: 'text-green-600 bg-green-50 border-green-200',
    warning: 'text-yellow-600 bg-yellow-50 border-yellow-200',
    poor: 'text-red-600 bg-red-50 border-red-200',
  }

  return (
    <Card className={`${statusColors[status]} border`}>
      <CardContent className="p-4">
        <div className="text-center">
          <div className="text-2xl font-bold">{value}</div>
          <div className="text-sm">{title}</div>
        </div>
      </CardContent>
    </Card>
  )
}
```

## ğŸ¤” æ€è€ƒé¢˜

1. å¦‚ä½•è®¾è®¡æœ‰æ•ˆçš„å‘Šè­¦ç­–ç•¥é¿å…å‘Šè­¦ç–²åŠ³ï¼Ÿ
2. å¦‚ä½•å¹³è¡¡ç›‘æ§çš„å…¨é¢æ€§å’Œæ€§èƒ½å½±å“ï¼Ÿ
3. å¦‚ä½•å»ºç«‹æœ‰æ•ˆçš„æ•…éšœå“åº”æµç¨‹ï¼Ÿ
4. å¦‚ä½•åˆ©ç”¨ç›‘æ§æ•°æ®è¿›è¡Œå®¹é‡è§„åˆ’ï¼Ÿ

## ğŸ“š æ‰©å±•é˜…è¯»

- [Web Vitals ç›‘æ§æŒ‡å—](https://web.dev/vitals/)
- [SRE å®è·µæŒ‡å—](https://sre.google/sre-book/table-of-contents/)
- [ç›‘æ§ç³»ç»Ÿè®¾è®¡](https://prometheus.io/docs/introduction/overview/)
- [å‘Šè­¦æœ€ä½³å®è·µ](https://docs.datadoghq.com/monitors/guide/best-practices/)

## ğŸ‰ æ­å–œå®Œæˆï¼

è‡³æ­¤ï¼Œæ‚¨å·²ç»å®Œæˆäº†æ•´ä¸ª Next.js 14+ Todo List å­¦ä¹ è·¯å¾„ï¼ä»é¡¹ç›®åˆå§‹åŒ–åˆ°ç”Ÿäº§éƒ¨ç½²ï¼Œä»åŸºç¡€åŠŸèƒ½åˆ°é«˜çº§ç‰¹æ€§ï¼Œæ‚¨å·²ç»æŒæ¡äº†ç°ä»£å…¨æ ˆ Web å¼€å‘çš„æ ¸å¿ƒæŠ€èƒ½ã€‚

ç»§ç»­å®è·µå’Œæ¢ç´¢ï¼Œæˆä¸ºæ›´ä¼˜ç§€çš„å¼€å‘è€…ï¼ğŸš€
